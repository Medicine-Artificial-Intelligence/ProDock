name: Test & Lint

on:
  push:
    branches: ["refactor", "main", "staging"]
  pull_request:
    branches: ["main"]
  workflow_dispatch:
    inputs:
      run_heavy:
        description: "Ignored in this workflow (heavy job removed)"
        required: false
        default: "false"

permissions:
  contents: read

env:
  CONDA_ENV_NAME: prodock-env

jobs:
  build:
    name: Build, lint, test (minimal)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Miniconda
        uses: conda-incubator/setup-miniconda@v2
        with:
          auto-update-conda: true
          python-version: 3.11.0

      - name: Install mamba
        run: |
          conda install -n base -c conda-forge mamba -y

      - name: Create minimal conda env (openmm + pdbfixer)
        run: |
          # create env with required binary packages (minimal)
          mamba create -n "${CONDA_ENV_NAME}" -c conda-forge -y \
            python=3.11 openmm=8.3.1 pdbfixer libstdcxx-ng libgcc-ng

          # compute env prefix and publish to GITHUB_ENV so following steps can use it
          CONDA_BASE=$(conda info --base)
          ENV_PREFIX="${CONDA_BASE}/envs/${CONDA_ENV_NAME}"
          echo "ENV_PREFIX=${ENV_PREFIX}" >> $GITHUB_ENV
          # export LD_LIBRARY_PATH at runtime pointing to conda env lib dir
          echo "LD_LIBRARY_PATH=${ENV_PREFIX}/lib:\$LD_LIBRARY_PATH" >> $GITHUB_ENV

      - name: Install pip requirements (allow pip-install of rdkit/openbabel/vina)
        run: |
          if [ -f requirements.txt ]; then
            # Do NOT let pip overwrite openmm/pdbfixer installed by conda.
            # We allow rdkit/openbabel/vina to be installed via pip from requirements.txt.
            grep -vE '^(openmm|pdbfixer)' requirements.txt > reqs-pip.txt || true
            conda run -n "${CONDA_ENV_NAME}" --no-capture-output python -m pip install --upgrade pip
            conda run -n "${CONDA_ENV_NAME}" --no-capture-output python -m pip install -r reqs-pip.txt
          fi

      - name: Diagnostic: verify OpenMM import & libstdc++ symbol
        run: |
          echo "ENV_PREFIX=${ENV_PREFIX}"
          echo "LD_LIBRARY_PATH=${LD_LIBRARY_PATH}"
          if [ -f "${ENV_PREFIX}/lib/libstdc++.so.6" ]; then
            echo "conda libstdc++.so.6 present; checking symbols (GLIBCXX_3.4.30)..."
            strings "${ENV_PREFIX}/lib/libstdc++.so.6" | grep GLIBCXX_3.4.30 || true
          else
            echo "conda libstdc++.so.6 NOT found under ${ENV_PREFIX}/lib"
          fi

          # try importing openmm inside the conda env (one-line)
          conda run -n "${CONDA_ENV_NAME}" --no-capture-output python -c "import openmm; print('openmm imported OK', getattr(openmm,'__file__',None))"

      - name: Lint with flake8
        run: |
          conda run -n "${CONDA_ENV_NAME}" --no-capture-output python -m pip install flake8
          conda run -n "${CONDA_ENV_NAME}" --no-capture-output python -m flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || true
          if [ -x ./lint.sh ]; then ./lint.sh || true; fi

      - name: Run tests (pytest)
        env:
          LD_LIBRARY_PATH: ${{ env.LD_LIBRARY_PATH }}
        run: |
          # Ensure runtime uses conda env lib dir and run tests inside the env.
          # Use single-quoted bash -lc to avoid YAML/quote collisions.
          conda run -n "${CONDA_ENV_NAME}" --no-capture-output bash -lc 'export LD_LIBRARY_PATH="${ENV_PREFIX}/lib:${LD_LIBRARY_PATH:-}"; python -c "import sys,openmm; print(\"python\", sys.version.split()[0], \"openmm\", getattr(openmm, \"__file__\", None))"; if [ -x ./pytest.sh ]; then ./pytest.sh; else pytest -q; fi'
